#!/bin/sh

if [[ $# -ne 1 ]]; then
	echo "Usage: $0 INSTANCE-ID|NAME [-d] [-v] [-s]"
	exit 1
fi

SHOULD_USE_FIRST_INSTANCE=0
SHOULD_PREPROD=0
SHOULD_PROD=0
SHOULD_DOCKER=0
SHOULD_VENV=0
SHOULD_SHELL=0

while getopts "dvs" opt; do
  case $opt in
  	1)
      SHOULD_USE_FIRST_INSTANCE=1
      ;;		
    e)
      SHOULD_PREPROD=1
      ;;
    o)
      SHOULD_PROD=1
      ;;
    d)
      SHOULD_DOCKER=1
      ;;
    v)
      SHOULD_VENV=1
      ;;
    s)
      SHOULD_SHELL=1
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      exit 1
      ;;
  esac
done


ORIGINAL_IFS=$IFS
DOCKER_COMMAND='type docker >/dev/null 2>&1 && sudo docker exec -ti $(sudo docker ps --filter "name=-app-" --format "table {{.ID}}\t{{.Names}}" | grep -v CONTAINER | awk "{print \$1}") bash || echo "spoon cannot docker"'
VENV_COMMAND_DOCKER='[[ -f ../virtualenv/bin/activate ]] && . ../virtualenv/bin/activate || echo "spoon cannot venv"'
VENV_COMMAND_CHEF="SERVICE_NAME=`ps aux | grep gunicorn | grep 'opt/prezi' | head -n1 | sed 's~.*/opt/prezi/\(.*\)/versions.*~\1~g'` && cd /opt/prezi/$SERVICE_NAME/current && . bin/virtualenv || echo 'spoon cannot venv'"
[[ SHOULD_DOCKER = 1 ]] && VENV_COMMAND=$VENV_COMMAND_DOCKER || VENV_COMMAND=$VENV_COMMAND_CHEF

### try instance id first, add i- prefix if missing

NODES=$(aws ec2 describe-instances --instance-ids $(echo "i-$1" | sed s/^i-i-/i-/) 2>/dev/null)
NODE_NUM=$(echo $NODES | jq '.Reservations | length')
if [[ $NODE_NUM -eq 1 ]]; then
	IP=$(echo $NODES | jq .Reservations[0].Instances[0].PublicIpAddress | sed 's/"//g')
	ssh -l root $IP
	exit 0
fi


### search for name if instance-id yields no results

NODES=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=*$1*")
NODE_NUM=$(echo $NODES | jq '.Reservations | length')
if [[ $NODE_NUM -eq 1 ]] || [[ $SHOULD_USE_FIRST_INSTANCE -eq 1 ]]; then
	IP=$(echo $NODES | jq .Reservations[0].Instances[0].PublicIpAddress | sed 's/"//g')
	ssh -l root $IP
	exit 0
fi

if [[ $NODE_NUM -eq 0 ]]; then
	echo "No instances found for $1"
	exit 1
fi

# the grepping at the end could probably be done in jq as well but I already don't understand my own jq expression
NODE_NAMES=$(echo $NODES | jq '.Reservations | map(.Instances[0] | (.Tags | map(select(.Key == "Name").Value))[0] + "__" + .PublicIpAddress + "__(" + .State.Name + ")")' | grep -v "\[\|\]" | sed "s/\"//g" | sed "s/,//g"| xargs)
IFS="^"
NODE_NAMES=$(echo $NODE_NAMES | sed 's/ /\^/g' | sed 's/__/    /g')

echo "*) all of the following (csshx)"
select name in $NODE_NAMES; do : ; break; done
IFS=$ORIGINAL_IFS

if [[ $REPLY == '*' ]]; then
	IPS=$(echo $NODES | jq '.Reservations | map(.Instances[0].PublicIpAddress)' | grep -v "\[\|\]" | sed "s/[\",]//g" | xargs)
	csshx --login root $IPS
else
	(( NODE_INDEX = $REPLY - 1 ))
	IP=$(echo $NODES | jq .Reservations[$NODE_INDEX].Instances[0].PublicIpAddress | sed s/\"//g)
	ssh -o StrictHostKeyChecking=no -l root $IP
fi
