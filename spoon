#!/usr/bin/env bash

spoon_usage_and_help() {
    if [[ $# -lt 1 ]]; then
        print_help
        exit 1
    fi

    if has_short_flag h "$@" || has_long_flag help "$@"; then
        print_help
        exit 0
    fi
}

print_help() {
    echo "usage: spoon [flags] <identifier>"
}

verbose_log() {
    [[ "${arg_verbose}" = 1 ]] && echo "${@}" >&2
}

################################################################################################
################################################################################################

spoon_set_args() {
    identifier="${*: -1}"

    if [[ "${identifier}" =~ ^- ]]; then
        echo identifier must not be empty
        exit 1
    fi

    if has_short_flag i "$@" || has_long_flag instance-id "$@"; then arg_instance_id=1; else arg_instance_id=0; fi
    if has_short_flag p "$@" || has_long_flag preprod "$@"; then arg_preprod=1; else arg_preprod=0; fi
    if has_short_flag P "$@" || has_long_flag prod "$@"; then arg_prod=1; else arg_prod=0; fi
    if has_short_flag 1 "$@" || has_long_flag first "$@"; then arg_first=1; else arg_first=0; fi
    if has_short_flag a "$@" || has_long_flag all "$@"; then arg_all=1; else arg_all=0; fi
    if has_short_flag n "$@" || has_long_flag dry-run "$@"; then arg_dry_run=1; else arg_dry_run=0; fi
    if has_short_flag d "$@" || has_long_flag docker "$@"; then arg_docker=1; else arg_docker=0; fi
    if has_short_flag v "$@" || has_long_flag verbose "$@"; then arg_verbose=1; else arg_verbose=0; fi
    if has_short_flag V "$@"; then arg_verbose=1 && arg_verybose=1; else arg_verybose=0; fi
}

has_short_flag() {
    flag="$1"
    shift
    args="$*"
    for arg in $args; do
        if [ "${arg:0:1}" = - ] && [ "${arg:1:1}" != - ] && [[ "$arg" =~ $flag ]]; then
            return 0
        fi
    done
    return 1
}

has_long_flag() {
    flag="$1"
    shift
    args="$*"
    for arg in $args; do
        if [ "${arg:0:2}" = -- ] && [[ "$arg" == "--$flag" ]]; then
            return 0
        fi
    done
    return 1
}

spoon_check_args() {
    if [[ "${arg_prod}" = 1 ]] && [[ "${arg_preprod}" = 1 ]]; then
        echo "Invalid arguments: -P/--prod and -p/--preprod are mutually exclusive."
        exit 1
    fi
    if [[ "${arg_first}" = 1 ]] && [[ "${arg_all}" = 1 ]]; then
        echo "Invalid arguments: -1/--first and -a/--all are mutually exclusive."
        exit 1
    fi
}

spoon_verbose_print_args() {
    if [[ "${arg_verbose}" = 1 ]]; then
        echo "[spoon] identifier=${identifier}"
        echo "[spoon] arg_instance_id=${arg_instance_id}"
        echo "[spoon] arg_preprod=${arg_preprod}"
        echo "[spoon] arg_prod=${arg_prod}"
        echo "[spoon] arg_first=${arg_first}"
        echo "[spoon] arg_dry_run=${arg_dry_run}"
    fi
}

################################################################################################
################################################################################################

spoon_get_instances_from_aws() {
    if [[ $arg_instance_id = 1 ]]; then
        nodes=$(query_aws_by_id "$identifier")
    else
        nodes=$(query_aws_by_name "$identifier")
    fi
    # I don't want to cram the entire if statement into the condition of another one
    # shellcheck disable=SC2181
    if [[ "$?" -ne 0 ]]; then
        echo "Encountered an error while using awscli. Please make sure it's installed and you are authorized to make requests."
        exit 1
    fi

    nodes="$(echo "${nodes}" | jq 'sort_by(.service)')"
    [[ "${arg_verybose}" = 1 ]] && echo -e "[spoon] instances returned from aws:\\n${nodes}"

    node_count=$(echo "${nodes}" | jq '. | length')
    if [[ "${node_count}" -eq 0 ]]; then
        echo "No instances found for identifier '${identifier}'."
        exit 1
    fi
}

query_aws() {
    verbose_log "[spoon] querying aws..."
    # The backticks are part of the JMESPath expression and should be
    # passed literally, not interpolated - disable relevant shellcheck rule.
    # shellcheck disable=SC2016
    if nodes="$(aws ec2 describe-instances --query 'Reservations[*].Instances[*].{id: InstanceId, ip: PublicIpAddress, state: State.Name, service: (Tags[?Key == `"Name"`].Value)[0]}[0]' "${@}")"; then
        echo "${nodes}"
    else
        return 1
    fi
}

query_aws_by_name() {
    query_aws --filters "Name=tag:Name,Values=*$1*"
}

query_aws_by_id() {
    query_aws --instance-ids "$1"
}

################################################################################################
################################################################################################

spoon_filter_for_environment() {
    if [[ $arg_preprod = 1 ]]; then
        nodes=$(echo "${nodes}" | jq 'map(select(.service | test("preprod|-pp")))')
        verbose_log "[spoon] nodes after filtering for preprod: ${nodes}"
        node_count=$(echo "${nodes}" | jq '. | length')
        if [[ "${node_count}" -eq 0 ]]; then
            echo "No instances found for identifier '${identifier}' after filtering for preprod."
            exit 1
        fi
    elif [[ $arg_prod = 1 ]]; then
        nodes=$(echo "${nodes}" | jq 'map(select(.service | test("preprod|-pp") | not))')
        verbose_log "[spoon] nodes after filtering for prod: ${nodes}"
        node_count=$(echo "${nodes}" | jq '. | length')
        if [[ "${node_count}" -eq 0 ]]; then
            echo "No instances found for identifier '${identifier}' after filtering for prod."
            exit 1
        fi
    fi
}

spoon_filter_for_first() {
    if [[ $arg_first = 1 ]]; then
        nodes=$(echo "${nodes}" | jq '[.[0]]')
        verbose_log -e "[spoon] first instance selected:\\n${nodes}"
        node_count=1
    fi
}

spoon_select_from_multiple() {
    if [[ $arg_all = 0 ]] && [[ $node_count -gt 1 ]]; then
        nodes_data="$(echo "${nodes}" | jq '.[] | .id + " " + .service + " " + .ip + " (" + .state + ")"' | tr -d '\"')"
        echo "${nodes_data}"| nl '-s) ' | column -t
        echo "*)  all"
        read -rp '==> ' reply
        if [[ "${reply}" = "" ]]; then
            verbose_log "[spoon] no instances selected; spoon will now exit."
            exit 0
        fi
        if [[ "${reply}" = '*' ]]; then
            verbose_log all instances selected
        else
            jq_range_expression="$(jqrangify "${reply}")"
            [[ "${arg_verybose}" = 1 ]] && echo "[spoon] jq range expression: ${jq_range_expression}"
            if ! nodes="$(echo "${nodes}" | jq "${jq_range_expression}" 2>/dev/null)"; then
                echo "[spoon] jq error: invalid selector"
                exit 1
            fi
            node_count=$(echo "${nodes}" | jq '. | length')
            if [[ "${node_count}" -eq 0 ]]; then
                echo "[spoon] no instances selected; spoon will now exit."
                exit 0
            fi
            [[ "${arg_verybose}" = 1 ]] && echo -e "[spoon] selected instances:\\n${nodes}"
        fi
    fi
}

jqrangify() {
    # The easiest way I found to select multiple items, including ranges, from the array
    # is converting all indices to jq range expressions to extract subarrays
    # and adding these all together.
    # e.g '1, 3, 5-10' --> jq '.[0:1] + .[2:3] + .[4:10]'
    expr=""
    for item in $(echo "${*}" | tr , ' '); do
        # note: for single numbers 'lower' and 'upper' end up being the same
        lower="${item//-*/}"
        upper="${item//*-/}"
        # arrays are 0-indexed, spoon numbers instances from 1, hence the substraction
        jqrangified_item="$((lower - 1)):${upper}"
        expr="${expr} .[${jqrangified_item}] +"
    done
    # append [] at the end to deal with the trailing + sign
    echo "${expr} []" | xargs
}

################################################################################################
################################################################################################

spoon_ssh() {
    node_count=$(echo "${nodes}" | jq '. | length')
    verbose_log "[spoon] number of instances: ${node_count}"
    if [[ "${node_count}" -gt 1 ]]; then
        ips=$(echo "${nodes}" | jq '.[].ip' | tr -d '"' | xargs)
        verbose_log "[spoon] IP addresses:"
        [[ "${arg_verbose}" = 1 ]] && for ip in ${ips}; do echo "${ip}"; done
        ssh_multiple "${ips}"
    else
        ip=$(echo "${nodes}" | jq '.[0].ip' | tr -d '"')
        verbose_log "[spoon] IP address: ${ip}"
        ssh_single -o StrictHostKeyChecking=no -l root  "${ip}"
    fi
}

ssh_single() {
    [[ "${arg_dry_run}" = 1 ]] && exit 0
    verbose_log "[spoon] calling ssh"
    if [[ "${arg_docker}" = 1 ]]; then
        ssh "${@}" -t 'HN=`hostname | cut -f 2 --delimiter=-`; INST_ID=`docker ps | grep $HN-app | cut -f 1 -d " "`; docker exec -ti $INST_ID bash -c '"'"'bash --init-file <(echo ". ../virtualenv/bin/activate")'"'"
    else
        ssh "${@}"
    fi
}

ssh_multiple() {
    [[ "${arg_dry_run}" = 1 ]] && exit 0
    check_cssh_availability
    if [[ "$TERM_PROGRAM" == "iTerm.app" ]]; then
        verbose_log "[spoon] calling i2cssh"
        # I actually need the word splitting here, hence the lack of quotes
        # shellcheck disable=SC2086
        i2cssh --login root $1
        echo hint: press Cmd+Shift+I to send your keyboard input to all the instances
    else
        verbose_log "[spoon] calling csshx"
        # I actually need the word splitting here, hence the lack of quotes
        # shellcheck disable=SC2086
        csshx --login root $1
    fi
}

check_cssh_availability() {
    verbose_log "[spoon] TERM_PROGRAM is ${TERM_PROGRAM}"
    if [[ "${TERM_PROGRAM}" == iTerm.app ]]; then
        if ! command -v i2cssh >/dev/null; then
            echo Please install i2cssh to SSH to multiple instances.
            exit 1
        fi
    else
        if ! command -v csshx >/dev/null; then
            echo Please install csshX to SSH to multiple instances.
            exit 1
        fi
    fi
}

################################################################################################
### execution starts here
################################################################################################

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    spoon_usage_and_help "${@}"

    spoon_set_args "${@}"
    spoon_check_args
    spoon_verbose_print_args

    spoon_get_instances_from_aws
    spoon_filter_for_environment
    spoon_filter_for_first
    spoon_select_from_multiple

    spoon_ssh
fi
